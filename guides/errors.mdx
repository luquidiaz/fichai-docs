---
title: Manejo de Errores
description: 'Códigos de error y cómo manejarlos'
---

## Formato de errores

Cuando ocurre un error, la API retorna un objeto JSON con la siguiente estructura:

```json
{
  "error": "Mensaje descriptivo del error",
  "code": "ERROR_CODE"
}
```

## Códigos HTTP

| Código | Significado |
|--------|-------------|
| `200 OK` | Request exitosa |
| `400 Bad Request` | Parámetros inválidos |
| `401 Unauthorized` | API key faltante o inválida |
| `403 Forbidden` | API key expirada, inactiva, u origen no permitido |
| `404 Not Found` | Recurso no encontrado |
| `429 Too Many Requests` | Rate limit excedido |
| `500 Internal Server Error` | Error interno del servidor |

## Códigos de error

### Errores de autenticación (401)

| Código | Descripción |
|--------|-------------|
| `MISSING_API_KEY` | No se envió el header Authorization |
| `INVALID_API_KEY` | La API key no existe o tiene formato incorrecto |

```json
{
  "error": "API key is required",
  "code": "MISSING_API_KEY"
}
```

### Errores de autorización (403)

| Código | Descripción |
|--------|-------------|
| `API_KEY_EXPIRED` | La API key expiró |
| `API_KEY_INACTIVE` | La API key fue desactivada |
| `ORIGIN_NOT_ALLOWED` | El origen de la request no está permitido |

```json
{
  "error": "API key has expired",
  "code": "API_KEY_EXPIRED"
}
```

### Errores de recurso (404)

```json
{
  "error": "Desarrollo no encontrado",
  "code": "NOT_FOUND"
}
```

### Errores de rate limit (429)

```json
{
  "error": "Rate limit exceeded. Try again later.",
  "code": "RATE_LIMITED"
}
```

### Errores internos (500)

```json
{
  "error": "Error interno",
  "code": "INTERNAL_ERROR"
}
```

## Manejo de errores en código

### JavaScript

```javascript
async function fetchDesarrollos() {
  const response = await fetch(
    'https://app.fichai.com/api/public/desarrollos',
    {
      headers: { 'Authorization': `Bearer ${API_KEY}` }
    }
  );

  if (!response.ok) {
    const error = await response.json();

    switch (response.status) {
      case 401:
        throw new Error(`Authentication error: ${error.error}`);

      case 403:
        if (error.code === 'API_KEY_EXPIRED') {
          // Notificar al admin para renovar la key
          notifyAdmin('API key expired');
        }
        throw new Error(`Authorization error: ${error.error}`);

      case 429:
        // Implementar retry con backoff
        const retryAfter = response.headers.get('Retry-After') || 60;
        await sleep(retryAfter * 1000);
        return fetchDesarrollos(); // Reintentar

      case 404:
        return null; // Recurso no existe

      default:
        throw new Error(`API error: ${error.error}`);
    }
  }

  return response.json();
}
```

### Python

```python
import requests
import time

def fetch_desarrollos():
    response = requests.get(
        'https://app.fichai.com/api/public/desarrollos',
        headers={'Authorization': f'Bearer {API_KEY}'}
    )

    if response.status_code == 200:
        return response.json()

    error = response.json()

    if response.status_code == 401:
        raise AuthenticationError(error['error'])

    if response.status_code == 403:
        raise AuthorizationError(error['error'])

    if response.status_code == 429:
        retry_after = int(response.headers.get('Retry-After', 60))
        time.sleep(retry_after)
        return fetch_desarrollos()  # Retry

    if response.status_code == 404:
        return None

    raise APIError(error['error'])
```

## Retry con exponential backoff

Para errores transitorios (429, 500, timeouts), implementá retry con exponential backoff:

```javascript
async function fetchWithRetry(url, options, maxRetries = 3) {
  let lastError;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      if (response.status === 429 || response.status >= 500) {
        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
        await new Promise(r => setTimeout(r, delay));
        continue;
      }

      return response;
    } catch (error) {
      lastError = error;
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(r => setTimeout(r, delay));
    }
  }

  throw lastError;
}
```

<Tip>
  Siempre loggueá los errores de la API para poder debuguear problemas. Incluí el código de error, mensaje, y timestamp.
</Tip>
